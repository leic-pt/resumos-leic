---
title: Árvores Binárias
description: Árvores de Procura Binárias (BST).
path: /iaed/arvores-binarias
type: content
---

# Árvores Binárias

```toc

```

## Árvores de Procura Binárias (BST)

As _binary search trees_, BSTs, têm por base uma lógica bastante simples: considerando o nó atual como sendo a raiz de uma árvore, todos os nós que partem do seu filho [_esquerdo_](color:green) (inclusive) têm chave menor que a sua, e todos os nós que partem do seu filho [_direito_](color:red) (inclusive) têm chave maior que a sua. Estamos, portanto, perante uma abordagem recursiva ao problema, já que cada nó é a raiz de uma sub-árvore da árvore "maior", e cada sub-árvore tem de respeitar também este princípio.

![BST 1](./assets/0017-arv2.png#dark=1)

A [**pesquisa**](color:purple) de um dado nó pela árvore é sempre iniciada a partir da raiz. Verifica-se necessariamente uma de três situações:

- A chave do nó atual é **menor** que a chave pesquisada. Nesse caso, a pesquisa continua a partir do filho **direito** do nó atual;
- A chave do nó atual é **maior** que a chave pesquisada. Nesse caso, a pesquisa continua a partir do filho **esquerdo** do nó atual;
- A chave do nó atual é **igual** a chave pesquisada. Nesse caso, o nó atual é o nó desejado, e podemos parar a procura.

Caso cheguemos ao nó nulo, `NULL` em C, nenhum nó na árvore tem a chave pretendida, pelo que a pesquisa não teve sucesso.

[**Inserir**](color:blue) um nó na árvore tem uma lógica-base semelhante, com alguns _twists_ pelo meio. Iniciamos uma espécie de "procura" na raiz, e o objetivo será **percorrer a árvore de cima para baixo**, até encontrarmos o lugar certo para introduzir o novo elemento. Este **lugar certo** será o local onde tivermos encontrado `NULL`. Tal deve-se a à própria procura, tal como explicada acima, acabar por indiretamente descobrir o sítio correto de inserção da chave a procurar caso esta não seja encontrada: procurámos o caminho certo para encontrar a chave, caso ela estivesse na árvore, e não a encontrámos; se não está lá, então este será o local correto para a inserirmos!

[**Remover**](color:red) um elemento é bastante simples. Realizamos uma procura normal, e assim que encontrarmos o nó pretendido (seja esse nó $x$):

- Caso $x$ não tenha filhos, basta apenas apagá-lo;
- Caso $x$ tenha apenas um filho, redirecionamos o pai de $x$ para o seu filho e apagamos $x$.
- Caso $x$ tenha dois filhos, substituímo-lo pelo maior dos elementos à sua esquerda e apagamo-lo da sua posição original.

:::info[Elementos Máximo e Minímo]

Para encontrar o elemento com chave mais elevada, devemos procurar o **elemento mais à direita** da árvore; pelo contrário, para encontrar o elemento com chave mais baixa, devemos procurar o **elemento mais à esquerda**.

```c
link max(link h) {
  if (h == NULL || h->r == NULL)
      return h;
  else
      return max(h->r);
}

link min(link h) {
  if (h == NULL || h->l == NULL)
    return h;
  else
    return min(h->l);
}
```

:::

## Travessias pela Árvore

![BST 2](./assets/0017-arv2.png#dark=1)

### Travessia Pre-Order

Numa **travessia pre-order**, visitamos sempre a raiz **antes** de visitar os seus filhos (com visita entenda-se "guardar/imprimir o valor do nó"). Pegando na árvore acima, uma travessia pre-order pela mesma produziria um output `20, 12, 8, 2, 9, 18, 32, 23, 45`.

### Travessia In-Order

Numa **travessia in-order**, visitamos sempre a raiz depois de visitar o filho à esquerda e antes de visitar o filho à direita. Pegando na árvore acima, uma travessia in-order pela mesma produziria um output `2, 8, 9, 12, 18, 20, 23, 32, 45`. Em BSTs, esta travessia produzirá um output [**ordenado de forma crescente**](color:green)!

### Travessia Post-Order

Numa **travessia pre-order**, visitamos sempre a raiz **depois** de visitar os seus filhos. Pegando na árvore acima, uma travessia pre-order pela mesma produziria um output `2, 9, 8, 18, 12, 23, 45, 32, 20`.

## Árvores Binárias Equilibradas

As pesquisas em árvores de procura binária são, por norma, realizadas de forma eficiente ($O(\log{n}))$. O pior caso, contudo, é linear: basta olhar para o caso em que inserimos, por esta ordem, `1, 2, 3, 4, 5, 6`. Nesse caso, ficamos com uma árvore deste tipo:

![BST - Pior caso](./assets/0017-pior-caso.png#dark=2)

Esta árvore é, claro, **desiquilibrada**, podendo assim ficar até atrás de vetores ordenados (quando acompanhados de pesquisa binária). Assim sendo, fará sentido encontrar maneiras de **equilibrar** a árvore.

Árvores equilibradas têm como principal objetivo reduzir a complexidade temporal no pior caso de pesquisa na mesma, a troco de complexidade adicional na construção e manutenção das mesmas (através da técnica de **reequilibragem**). Vamos estudar duas variantes de árvores equilibradas: **árvores AVL** e **Red-Black**.

### Árvores AVL (Adelson-Velsky and Landis)

![arv2](./assets/0017-arv2.png#dark=1)

Qualquer operação na árvore tem $O(\log N)$

- BST em que, para cada nó interno,\
  a profundidade (height) de ambos os filhos difere, no máximo, em 1

A árvore fica desequilibrada quando se retira ou insere um elemento.

Para equilibrar uma árvore, aplicamos uma rotação no pai e nos filhos que estão desequilibrados.

### Inserção

- Inserir novo elemento, numa folha, como numa BST normal

Balance Factor = height(left) - height(right)

- Inserir novo elemento, numa folha, como numa BST
  normal
- Percorrer o caminho desde a nova folha até à raíz
  - Para cada nó encontrado, verificar se as alturas dos dois filhos
    (esquerdo e direito) não diferem em mais do que 1
  - Se diferirem, equilibrar a sub-árvore com raíz nesse nó,
    efectuando uma rotação (simples ou dupla)
- Após equilibrar a sub-árvore com raíz num determinado
  nó x, não será necessário equilibrar as sub-árvores com
  raíz nos antepassados de x
  - Terminar após uma equilibragem, ou quando atingirmos a raíz

### Equilibragem

- Rotação Simples I (left)

![esq](./assets/0017-esq.png#dark=1)

```c
link rotL(link h) {
  link x = h->r;
  h->r = x->l;
  x->l = h;
  return x;
}
```

- Rotação Simples II (right)

![dir](./assets/0017-dir.png#dark=1)

```c
link rotR(link h) {
  link x = h->l;
  h->l = x->r;
  x->r = h;
  return x;
}
```

- Rotação Dupla I (right-left)

![rl](./assets/0017-rl.png#dark=1)

- Rotação Dupla II (left-right)

![lr](./assets/0017-lr.png#dark=1)

### Resumo

- Caso 1:\
  Se o novo nó é inserido na sub-árvore da esquerda,\
  da subárvore da esquerda do elemento desequilibrado,\
  basta-nos aplicar uma rotação simples para a direita aplicada a esse elemento.

- Caso 2:\
  Se o novo nó é inserido na sub-árvore da direita,\
  da sub-árvore da direita do elemento desequilibrado,\
  basta-nos aplicar uma rotação simples para a esquerda aplicada a esse elemento.

- Caso 3:\
  Se o novo nó é inserido na sub-árvore da direita,\
  da sub-árvore da esquerda do elemento desequilibrado,\
  fazemos uma rotação dupla Esquerda-Direita.

- Caso 4:\
  Se o novo nó é inserido na sub-árvore da esquerda,\
  da subárvore da direita do elemento desequilibrado,\
  fazemos uma rotação dupla Direita-Esquerda.

### Remoção

- Remover um nó como numa BST normal
- Percorrer o caminho desde o nó removido até à raíz
  - Para cada nó encontrado, verificar se as alturas dos dois filhos
    (esquerdo e direito) não diferem em mais do que 1
  - Se diferirem, equilibrar a sub-árvore com raíz nesse nó,
    efectuando uma rotação simples ou uma rotação dupla
- Após equilibrar a sub-árvore com raíz num determinado
  nó x, poderá ser necessário equilibrar as sub-árvores
  com raízes nos antepassados de x
  - Terminar apenas quando atingirmos a raíz

### Desempenho

- Uma equilibragem (rotação dupla ou simples): $O(1)$
- Pesquisa: $O(\log N)$
  - Profundidade é $O(\log N)$, não é necessário equilibrar
- Inserção: $O(\log N)$
  - Procurar a posição para inserir é $O(\log N)$
  - Manter equilibrada é $O(\log N)$ : subir na árvore e equilibrar 1 vez
- Remoção: $O(\log N)$
  - Procurar o elemento a remover é $O(\log N)$
  - Manter equilibrada é $O(\log N)$ : subir na árvore e equilibrar no
    máximo $O(\log N)$ vezes

Aconselho vivamente a verem os exemplos nos slides\
acerca da manipulação desta estutura de dados.

---
title: FAQ - Projeto
description: FAQ sobre o Projeto
path: /lp/projeto/faq
type: guides
---

# FAQ - Projeto

```toc

```

Aqui podem encontrar algumas informa√ß√µes √∫teis sobre o Projeto de LP.

- Usem e abusem dos _built-ins_, eles s√£o vossos amigos; uma s√©rie de predicados pr√©-definidos para manipula√ß√£o de listas pode ser encontrada [aqui](https://www.swi-prolog.org/pldoc/doc/_SWI_/library/lists.pl), havendo contudo mais documenta√ß√£o para outras aplica√ß√µes que possam querer implementar.

- Escrevam o pseudo-c√≥digo num papel antes de o implementar - este conselho j√° faz sentido em outras linguagens, mas em Prolog ainda friso mais este ponto, principalmente quando √© poss√≠vel desenhar o processo em "√°rvore", √© mesmo √∫til.

- **As solu√ß√µes que teoricamente nem fa√ßam sentido podem funcionar** - se estiverem presos e tiverem uma ideia que _quase de certeza_ n√£o funciona, experimentem na mesma; na pior das hip√≥teses ficam na mesma, mas podem fazer progresso valioso a experimentar as coisas mais disparatadas.

- Os primeiros dias v√£o ser dif√≠ceis, e provavelmente v√£o ficar presos num ou noutro predicado - n√£o desanimem, √© completamente normal, se continuarem a trabalhar v√£o conseguir sair de l√°.

- Podem (e devem) pensar nos problemas como uma Resolu√ß√£o SLD - facilita bastante, na minha opini√£o.

- **Erro no enunciado - exemplo do predicado 9** - h√° uma men√ß√£o no exemplo a uma "Grelha", quando na verdade devia ser Puzzle (o que faz com que se tentarem copiar e colar o teste vos d√™ sempre falso).

- Se quiserem ver o qu√£o eficientes os vossos processos est√£o a ser/onde √© que os vossos processos est√£o a demorar mais, t√™m o predicado [profile](https://www.swi-prolog.org/pldoc/man?predicate=profile/1) que vos retorna um conjunto de estat√≠sticas sobre o programa (obrigado Afonso :D).

- **Se estiverem encalhados nalgum exerc√≠cio**, podem experimentar fazer o predicado 11 para n√£o ficarem sem fazer nada - √© o √∫nico, para al√©m do primeiro, que n√£o precisa de predicados definidos anteriormente.

- O sentimento geral √© que os predicados 3 e 8 s√£o os mais complicados - se ficarem encalhados neles n√£o se preocupem, √© completamente normal que demorem v√°rias horas/dias/semanas a pass√°-los.

## Aula de apoio ao projeto - prof. Maria Rem√©dios

- Predicados _built-in_ √∫teis:

  - `last/2`, que pode ser √∫til em situa√ß√µes em que queiram saber exatamente qual √© o √∫ltimo elemento de uma lista;

  - `subsumes_term /2`, que verifica se dois termos s√£o unific√°ceis **sem os unificar**;

  - `min/list/2` e `max_list/2`, para descobrir, respetivamente, o m√≠nimo e m√°ximo valores em rela√ß√£o aos elementos de uma lista;

  - `between/3`, particularmente √∫til para criar listas n√£o _hardcoded_ para os predicados relativos √†s permuta√ß√µes (n√£o inclui o 3.1.2);

  - `sum_list/2` para descobrir a soma de todos os elementos de uma lista;

  - `sort`, tendo este predicado v√°rias vers√µes (`/2, /4, ...`), para ordenar os elementos de uma lista - t√™m [aqui](https://www.swi-prolog.org/pldoc/man?section=builtinlist) este e mais outros predicados de ordena√ß√£o caso queiram explorar;

  - `nth0/3` e `nth1/3`, para obterem o elemento de uma lista dado o seu √≠ndice - com `nth0` consideramos que o primeiro √≠ndice √© 0, com `nth1` consideramos que √© 1;

  - `forall/2`, que retorna true se para uma dada condi√ß√£o, uma "a√ß√£o" puder ser provada.

- **N√£o se pode importar quaisquer bibliotecas**. Podemos, contudo, usar todos os predicados _built-in_ a que temos normalmente acesso - situa√ß√£o igual √† de FP, onde n√£o pod√≠amos importar bibliotecas mas pod√≠amos usar todas as fun√ß√µes "default".

- **Tenham cuidado com unifica√ß√µes indesejadas de vari√°veis** - h√° situa√ß√µes em que n√£o se pode usar o `findall` por causa disto mesmo; para al√©m disso , o `member` tamb√©m pode ter este problema; a unifica√ß√£o (ou a tentativa da mesma) pode ser, contudo, bastante √∫til em alguns casos, n√£o sendo sempre indesejada - longe disso.

## Aula de apoio ao projeto - prof. Pav√£o Martins

- Aconselha a que v√£o implementando os predicados pela ordem que s√£o dados, diz que essa ordem foi escolhida precisamente para nos facilitar o trabalho (e porque h√° alguns que n√£o funcionam se os anteriores estarem definidos);

- V√£o correndo os testes respetivos a cada predicado antes de passarem para o pr√≥ximo, para terem uma maior seguran√ßa de quem podem avan√ßar sem descurar erros mais f√°ceis de apanhar (tentem, claro, certificar-se que n√£o t√™m nenhum :P);

- Uma particularidade interessante do `setof` que o prof. levantou √© que o `setof` ordena a lista - pode ser √∫til no `permutacoes_soma`;

- Nos exemplos dos predicados que envolvem espa√ßos em comum, reparem nas **vari√°veis em comum** entre espa√ßos - elas v√£o ser a chave para implementar esses predicados corretamente;

- Para comparar vari√°veis, evitem usar o `=`, de unifica√ß√£o; procurem antes usar o `==` para fazer essa compara√ß√£o;

:::tip
Os professores tamb√©m falaram em detalhe sobre cada predicado, mas acho que ficava demasiado denso se viesse escrever o que √© que cada um disse sobre cada um dos 19 predicados; assim sendo, recomendo que caso tenham uma d√∫vida sobre algum predicado em concreto v√£o rever a aula em si, pode ser que tenham abordado a vossa d√∫vida. Se repararem nalguma coisa √∫til que os profs tenham dito que n√£o esteja aqui, falem comigo para ser adicionado!
:::

Tip minha - podem usar o predicado da matriz transposta em mais que um s√≠tio, mesmo quando n√£o √© explicitamente pedido - pode ser bastante √∫til ü§†!

(Esta sec√ß√£o vai sendo alterada conforme forem surgindo informa√ß√µes relevantes, se tiverem contribui√ß√µes que queiram ver aqui fa√ßam PR/digam-me no #lp üòÉ).
